# 海上战争模拟项目需求书

## 1. 引言

### 1.1 目的
本文档旨在详细描述海上战争模拟项目的需求和设计，为开发团队提供明确的开发指南，同时也作为项目评估和验收的依据。本项目将构建一个高度仿真的多层级海战兵棋系统，既可作为战术训练工具，也可作为AI研究平台。

### 1.2 范围
本文档涵盖海上战争模拟系统的功能需求、非功能需求、系统架构、数据结构设计等内容，包括游戏环境模拟、玩家控制、模型训练和数据管理等核心模块。系统将支持单人游戏、多人联网对战以及AI训练模式，为用户提供全面的海战模拟体验。

### 1.3 定义
- **实体**：指游戏中的可交互对象，如船只、飞机、导弹等
- **AI玩家**：由计算机控制的游戏参与者
- **模型训练**：使用机器学习算法优化AI玩家策略的过程
- **游戏状态**：描述游戏当前情况的数据集合
- **帧同步**：一种网络游戏同步机制，确保所有客户端在相同的游戏帧执行相同的操作
- **FOW (Fog of War)**：战争迷雾，限制玩家只能看到自己单位周围区域的机制


## 2. 游戏概述

### 2.1 游戏背景
本项目为海上战争模拟系统，旨在通过模拟海上战争场景，进行相关策略和模型的研究与训练。玩家将在海战环境中指挥各类舰船、飞机等单位，与敌方进行战略对抗。游戏背景设定在现代海战环境中，玩家需要考虑地形、天气、装备性能等多种因素，制定合理的战术策略。

### 2.2 主要功能
1. 海上战争场景模拟：包括海洋环境、天气系统、昼夜交替等
2. 多种实体类型及其交互：各类舰船、飞机、潜艇等单位的精确模拟
3. 多样化的玩家控制方式：支持鼠标、键盘操作以及命令系统
4. AI模型训练与优化：提供强化学习接口和训练环境
5. 游戏数据存储与管理：战局记录、回放系统和数据分析工具
6. 战术决策系统：提供战术建议和决策辅助工具
7. 多人对战系统：支持局域网和互联网联机对战

### 2.3 玩家角色和目标
玩家将扮演舰队指挥官，通过合理调配资源和单位，在海战中击败对手。游戏胜利条件包括消灭敌方关键单位、控制特定区域或完成特定任务目标。玩家需要综合考虑单位性能、地形优势、资源管理和战术配合，制定最优战略。

## 3. 游戏机制

### 3.1 单位和结构

#### 1. 武器系统
- **导弹**：远程精确打击武器，可根据用途分为：
    - 反舰导弹（AShM）：针对水面舰艇。
    - 防空导弹（SAM）：拦截来袭的空中目标。
    - 巡航导弹（LACM）：远程精确打击地面目标。
    - 弹道导弹（BMD）：高超音速或洲际打击武器。
- **鱼雷**：水下攻击武器，可分为：
    - 反舰鱼雷：用于攻击水面舰艇。
    - 反潜鱼雷：用于攻击潜艇。
    - 超空泡鱼雷：高速水下打击武器。
- **火炮**：
    - 舰炮：用于近距离对舰作战。
    - CIWS（近防系统）：用于拦截来袭导弹、无人机。
    - 对空火炮：防御低空威胁，如无人机或低飞战机。
- **电子战武器**：
    - 干扰弹：用于欺骗雷达或红外导引头。
    - 电磁脉冲（EMP）武器：短暂瘫痪敌方电子设备。
    - 主动干扰系统：干扰导弹制导。

#### 2. 实体类型
- 航空母舰：核心舰艇，具备远程投射能力，可搭载战斗机、预警机、无人机。
- 驱逐舰：机动性强，执行防空、反潜、导弹防御任务。
- 巡洋舰：配备强大防空与反舰火力，承担舰队防御核心角色。
- 潜艇：隐蔽性强，可用于侦察、战术打击，甚至战略核打击。
- 护卫舰：小型多用途战舰，负责护航、反潜任务。
- 补给舰：提供燃料、弹药、维修支持，延长舰队续航能力。
- 战斗机：空战主力，可执行制空、对舰、对地打击任务。
- 轰炸机：远程打击单位，可投掷炸弹、发射巡航导弹。
- 侦察机：执行情报收集、目标锁定任务。
- 无人机（UAV）：提供侦察、战斗、电子战支援。
- 导弹：某些战略导弹可作为独立实体，如洲际弹道导弹（ICBM）。

#### 3. 编组
编组系统允许玩家将不同舰艇或空中单位组织成编队，并提供战术控制：
- 自动编队：玩家可指定战术，如“防空编队”“反潜巡逻编队”。
- 编队优化：调整舰艇站位，如防空舰位于中心，反潜舰位于外围。
- 动态编组：单位可在战斗中重新调整编队，适应战况变化。

### 3.2 实体功能
实体功能涉及 C4ISR（指挥、控制、通信、计算机、情报、监视和侦察）系统，决定了各单位的战场感知能力。

#### 1. 探测
- 本体探测：单位自身雷达、声呐、红外传感器的探测能力。
- 数据链探测：舰队、编队共享目标信息，提高态势感知能力。

#### 2. 机动
- 路径机动：单位沿指定路径航行（自动避障、最短路径规划）。
- 操纵机动：玩家可手动控制速度、方向，实现复杂战术动作（如蛇形规避）。

#### 3. 开火
- 武器管理：决定何时、如何使用导弹、鱼雷、舰炮等。
- 自动目标分配：系统可智能分配火力，优先攻击最具威胁目标。

#### 4. 电磁对抗
- 电子干扰：对敌方雷达、通信进行干扰，使其无法锁定目标。
- 欺骗诱饵：释放假目标迷惑敌方导弹。
- 隐身模式：潜艇、隐形战斗机可减少雷达信号反射，避免探测。


## 4. 用户界面设计

### 4.1 界面布局
海上战争模拟游戏的界面设计需要兼顾战术指挥可视化、操作便捷性以及信息管理效率。界面主要由以下部分组成：

#### 1. 主游戏界面
3D战场地图：显示海洋地形、舰艇、飞机、潜艇等单位的实时位置。
单位状态指示：每个单位的血量、弹药、燃油、雷达状态、战损情况等信息可在悬停或选中时查看。
动态环境渲染：海浪、天气、昼夜变化影响战斗视野和行动效率。

#### 2. 控制面板
提供单位选择、移动指令、攻击指令、防御部署、电子战等战术指挥操作。
可快速切换舰队指挥模式（如单舰操作、编队指挥、战略级调度）。

#### 3. 资源显示
展示当前舰队的燃油、弹药、舰载机数量、补给进度等。
战场实时资源变动，如舰船损毁、补给消耗、维修进度等动态反馈。

#### 4. 小地图
提供战场全局态势，标注已探测到的敌方目标、航路点、任务区域等。
可进行区域放大、切换战场视角（战术/战略模式）。

#### 5. 信息面板
显示游戏实时事件，如导弹发射、舰船损毁、战斗损失报告。
可查看单位详情，切换不同单位的数据，如战斗机状态、舰船损伤报告等。

#### 6. 3D战场支持
3D视角切换：战术级（近距离）、战役级（中距离）、战略级（全局）。
多视角模式：上帝视角、舰桥视角、武器视角（如导弹追踪摄像头）。
战斗回放系统：支持回顾战斗过程，分析战术决策。

### 4.2 交互设计
#### 1. 鼠标操作
- 左键：选择单位、指定目标、拖动画面移动视角。
- 右键：执行单位行动（如移动、攻击）。
- 滚轮：缩放视角，切换战术/战略模式。
- 拖拽操作：圈选编队、规划航线。
#### 2. 键盘快捷键
数字键（1-9）：快速切换舰队/单位。
WASD：控制战场视角移动。
F1-F6：切换不同指挥模式（攻击、防御、巡逻、补给、撤退）。
R：切换雷达模式，显示敌方探测情况。
T：切换热成像/夜间模式。
P：暂停/战术回放。
#### 3. 菜单系统
提供战局设置、游戏存档、战术预设、战斗回放选项。
可调整游戏速度、AI难度、天气环境等。

# 5. 技术架构

### 5.1 设计思路
本系统采用客户端 - 服务器 (C/S) 架构，结合帧同步技术实现多人对战功能。系统架构具有以下特点：

#### 1. 分层设计
- **表现层（客户端）**
    - 负责 3D 渲染、界面显示、用户交互。
    - 采用现代游戏引擎（如 Unity/Unreal）。
- **逻辑层（游戏核心）**
    - 处理游戏规则、战斗计算、AI 决策。
- **数据层**
    - 管理游戏状态、实体状态、战场环境。
    - 采用关系型数据库（MySQL） + NoSQL（MongoDB/Redis）进行存储。
- **网络层**
    - 处理客户端与服务器通信，确保数据同步与安全。

#### 2. 模块化结构
- 游戏引擎模块：提供基础游戏功能，如渲染、物理计算等。
- 战斗系统模块：处理单位间的交互和战斗结果计算。
- AI 系统模块：实现 AI 玩家的决策逻辑。
- 网络同步模块：确保多玩家游戏的状态一致性。
- 数据管理模块：处理游戏数据的存储和读取。

#### 3. 运行模式
- 单机模式：客户端内置简化服务器，支持与 AI 对战。
- 联机模式：连接到远程服务器，支持多人对战。
- 训练模式：专为 AI 训练优化的高速模拟环境。

### 5.2 功能划分

#### 1. 游戏引擎
   - 处理游戏的核心逻辑，包括游戏的玩法规则，根据玩家的操作和 AI 的决策按步长来更新游戏状态。
    - 组件化设计：将游戏元素分解为独立的组件，如坐标、速度、血量、武器等。
    - 游戏引擎交互采用组件、系统架构，提升系统运算效能，包含机动、攻击、防御、探测、通信等系统机制。
    - 支持多玩家联机对战。
    - 提供信息交互的 API。
    - 采用对象池进行实体管理，提升系统效率。

#### 2. 服务端
   - 包括游戏引擎和通信服务端，负责处理游戏逻辑和状态同步，负责玩家匹配和游戏创建，存储用户数据和游戏记录。
    - 处理游戏逻辑和状态同步。
    - 负责玩家匹配和游戏创建。
    - 存储用户数据和游戏记录。

#### 3. 客户端
- 包括游戏引擎、前端显示、通信客户端，负责渲染游戏场景，接收服务器发送的游戏状态更新，处理用户输入和游戏控制。
    - 渲染游戏场景。
    - 接收服务器发送的所有玩家指令更新游戏状态。
    - 可加载 AI 提供单人游戏模式。
    - 处理用户输入和游戏控制。
    - 提供游戏界面和交互功能。
    - 支持有引擎容器化，进行 AI 分布式训练。

### 5.3 网络通信
本系统采用帧同步技术实现多人游戏，具有以下特点：

#### 1. 帧同步机制
- 固定帧率：游戏以固定的帧率（如 30FPS）运行。
- 操作同步：服务器收集并广播所有玩家的操作指令。
- 确定性计算：相同的输入产生相同的结果，确保游戏状态一致。
- 帧锁定：客户端等待所有玩家的操作后才进行下一帧计算。

#### 2. 网络协议选择
- 使用 UDP 协议作为主要传输协议，降低延迟。
- 关键数据使用 TCP 协议确保可靠传输。

#### 3. 数据同步策略
- 初始同步：游戏开始时完整同步游戏状态。
- 增量同步：游戏过程中只同步变化的数据。
- 周期性完整同步：定期进行完整同步，防止状态偏差累积。
- 关键事件同步：重要事件（如战斗结果）强制同步。

#### 4. 延迟处理
- 预测补偿：客户端预测其他玩家可能的操作。
- 平滑处理：对网络抖动进行平滑处理，减少视觉跳跃。
- 延迟隐藏：通过动画和视觉效果掩盖网络延迟。
- 断线重连：支持玩家断线后重新连接，自动同步游戏状态。

#### 5. 网络安全
- 数据加密：敏感数据传输采用加密算法。
- 反作弊机制：检测和防止客户端作弊行为。

### 5.4 数据管理
本系统的数据管理模块负责处理游戏数据的存储、读取和分析，具有以下特点：

#### 1. 数据存储方案
- 关系型数据库（MySQL）：存储用户信息、游戏配置等结构化数据。
- NoSQL 数据库（MongoDB）：存储游戏状态、战斗记录等非结构化数据。
- 本地文件系统：存储游戏资源、配置文件和本地存档。
- 内存数据库（Redis）：缓存频繁访问的数据，提高性能。

#### 2. 游戏状态管理
- 状态快照：定期创建游戏状态快照，支持回放和恢复。
- 增量更新：记录状态变化，减少存储空间需求。
- 状态回滚：支持游戏状态回滚，用于处理异常情况。
- 分布式状态：大型游戏中的状态可分布在多个服务器上。

#### 3. 数据备份与恢复
- 自动备份：定期自动备份关键数据。
- 增量备份：只备份变化的数据，减少备份时间。
- 快速恢复：支持快速恢复游戏状态。
- 版本控制：维护多个备份版本，支持回滚到任意版本。

#### 4. 数据分析功能
- 战斗分析：分析战斗过程和结果，提供战术建议。
- 性能分析：监控系统性能，识别瓶颈。
- 玩家行为分析：分析玩家行为模式，优化游戏体验。
- AI 训练数据分析：为 AI 训练提供数据支持。

#### 5. 海战特有数据管理
- 战场环境数据：管理海洋、天气、地形等环境数据。
- 传感器数据模拟：模拟雷达、声呐等传感器数据。
- 情报数据管理：处理侦察获取的情报数据。
- 指挥决策数据：记录和分析指挥决策过程。

### 5.5 开发工具和环境
- 开发语言：C++，Python。
- 游戏引擎：后端 C++，前端 UE。
- 机器学习框架：PyTorch, Ray。
- 数据库：MySQL，Redis。
- 开发环境：支持跨平台开发 (第二阶段)。

## 6. 数据结构

### 6.1 游戏状态数据结构 `game_state`
游戏状态数据结构用于存储游戏在某一时刻的整体信息。具体包含以下内容：
- **地图信息**：涵盖地图的大小，如长和宽，以及地形分布情况，像海洋区域的具体坐标范围等。
- **单位状态**：以列表形式记录每个单位的详细信息，每个单位有唯一的标识ID、所属类型（如航空母舰、驱逐舰等）、当前所在位置以及状态（如活跃、受损、被摧毁等）。
- **资源情况**：记录游戏中的各类资源，如燃料和弹药的数量。
- **游戏时间**：精确到秒，反映游戏从开始到当前时刻所经过的时长。

### 6.2 算子数据结构 `unit_info`
算子数据结构用于描述游戏中的各种实体单位。其属性包括：
- **唯一ID**：用于区分不同的单位。
- **单位类型**：明确单位是船只（如航空母舰、驱逐舰、潜艇、补给舰）、飞机（如战斗机、轰炸机、侦察机）等具体类型。
- **位置信息**：以坐标形式表示单位在地图上的位置。
- **状态信息**：表明单位当前的状态，如是否处于活跃状态、是否受损或已被摧毁。
- **额外属性**：包含单位的一些特性，如移动速度、攻击能力等。
        

### 6.3 通信消息数据结构
通信消息数据结构用于不同组件之间的信息传递，分为以下几种情况：

#### 1.战斗数据消息机制
游戏引擎内部消息采用简单的消息格式，包含消息类型和消息内容。消息类型可以是单位移动、单位攻击等。消息内容则根据消息类型的不同，包含相应的具体信息，如单位移动消息会包含单位ID和目标位置，单位攻击消息会包含攻击者ID和目标ID。

#### 2.前端后端通信机制（gRPC）
使用Protocol Buffers（protobuf）来定义消息结构。例如，对于单位移动操作，会定义单位移动请求消息和单位移动响应消息。请求消息包含单位ID和目标位置的坐标信息，响应消息则表明操作是否成功。同时，会定义游戏服务，包含具体的操作方法，如单位移动方法。

#### 3.各终端之间的通信（Socket、DDS）
对于Socket和DDS通信，可以使用类似的消息结构。通常采用JSON格式，包含消息类型和具体的消息内容，如单位移动消息会包含单位ID和目标位置。

### 6.5 数据管理

#### 1.存储游戏状态和模型参数
采用不同类型的数据库来存储不同类型的数据。使用关系型数据库（如MySQL）存储结构化数据，如用户信息、游戏配置等；使用NoSQL数据库（如MongoDB）存储非结构化数据，如游戏状态、战斗记录等。将游戏状态和模型参数分别存储在相应的数据库集合中。

#### 2.支持数据的读取和更新
可以根据数据的唯一标识（如ID）或其他条件从数据库中读取和更新数据。例如，根据游戏状态的ID读取特定时刻的游戏状态，或者根据模型参数的ID更新模型的权重和偏置信息。

#### 3.实现数据备份和恢复机制
定期对数据库中的关键数据进行备份，以防止数据丢失。可以采用全量备份和增量备份相结合的方式，减少备份时间和存储空间的占用。同时，支持在需要时快速恢复游戏状态，并且维护多个备份版本，以便可以回滚到任意历史版本。

#### 4.提供数据分析功能
使用数据分析工具（如Pandas、NumPy）对游戏数据进行深入分析。可以进行战斗分析，如计算平均攻击次数、胜率等，为玩家提供战术建议；进行性能分析，监控系统的性能指标，识别潜在的瓶颈；分析玩家的行为模式，了解玩家的喜好和习惯，从而优化游戏体验；为AI训练提供数据支持，通过对大量游戏数据的分析来优化AI玩家的策略。

## 7. 非功能需求

### 7.1 性能要求
#### 1. 保证游戏的流畅运行，响应时间在可接受范围内
#### 2. 支持大规模的实体模拟和交互
#### 3. 优化资源使用，减少内存占用


### 7.2 可靠性要求
#### 1. 确保数据的安全性和完整性
#### 2. 具备错误处理和恢复机制
#### 3. 系统稳定性保障措施
#### 4. 支持断点重连功能



